保护模式(protected mode)编程

1.实模式(real mode)和保护模式有什么区别?
(1) 实模式
段地址16位:偏移地址16位
物理地址=段地址*10h+偏移地址
段的最大长度=64K=10000h
每个段同时具备3个权限:读、写、执行
中断向量表位于0:0~0:3FF, 每个中断向量为4字节
(2) 保护模式
段地址仍旧为16位
偏移地址为16位或32位
物理地址=gdt[段地址].base_addr + 偏移地址
其中gdt是结构数组, 每个元素均为8字节宽度的结构
段的最大长度为4G
每个段的权限可以通过编程来设定:
可读+可写、可读+可执行、只读不可写、只执行不可读
中断向量表的首地址可以通过编程来设定, 每个中断
向量的宽度为8字节.

2. gdt(global descriptor table)
设gdt的物理地址=2000h
gdt+00h  00,00,00,00, 00,00,00,00
gdt+08h  FF,FF,78,56, 34,93,4F,12
gdt+10h  FF,FF,78,56, 34,9B,4F,12
gdt+18h  ...
设ds=8, esi=10000h, 则ds:esi对应的物理地址
=12345678h+10000h = 12355678h
当我们把某个16位的值如8赋值给段寄存器时, 该值
称为selector(选择子)。

假定ds=8, gdt+8指向的8字节中有4个字节
(第2、3、4、7字节)构成base_addr=12345678h;
第0、1字节及第6字节的低4位构成limit=FFFFF
(limit就是该段的最大偏移地址), 故该段的长度
=100000h字节即1M;
第6字节的高4位及第5字节共12位用来规定段的属性
第6字节的高4位=4, 展开成二进制:
0 1 0 0
- - ===
| | |
| | +---保留
| +--D; 1=32位段, 0=16位段
+----granularity(粒度)
     1=段长度单位为4K, 0=段长度单位为字节

+1000 ~ 1FFF 为堆栈空间
普通的数据段base_addr=1000h, limit=FFF
expand_down段的base_addr=1000+FFF+1=2000h
limit=FFF
esp必须是负数


第5字节=93h, 展开成二进制:
1  0  0  1    0  0  1  1
-  ====  -    |  |  |  +---1=Accessed(描述符已访问过)
|  |     |    |  |  +---1=可写数据段或可读代码段
|  |     |    |  |      0=只读数据段或只执行代码段
|  |     |    |  +--1=conforming代码段
|  |     |    |       或expand_down堆栈段
|  |     |    |     0=普通段
|  |     |    +--0=数据段, 1=代码段
|  |     +---S;1=代码段或数据段,0=TSS、LDT、gate
|  |     tss=task state sement, ldt=local descriptor table
|  +---DPL(descriptor privilege level)
+---Present;1=该段存在, 0=该段不存在

DPL=00表示最高权限, 11表示最低权限
当某个进程要想对某个段寄存器进行赋值时,cpu会做
权限检查, 例如:

mov ax, 8
mov ds, ax; 这里CPU会做权限检查
当前进程的权限由cs的低2位(即
Current Privilege Level简称CPL)决定, 只有当
CPL <= 某个段描述符的DPL时, 该进程才可以访问
该段。
比如cs=1Bh, 它的二进制为
0001 1011
======~--
|     ||
|     ||
|     |+----CPL=3
|     +-----table indicator;0=GDT, 1=LDT
+-----------段地址 = (cs & FFF8) = 18h


用lgdt指令对gdtr寄存器赋值, gdtr一共有48位,
其中32位是gdt的首地址, 16位是gdt的limit;
例如:
lgdt fword ptr var; 前2字节是limit,后4字节是base

当把cr0寄存器(32位)的最低位改成1时,
cpu进入保护模式;
改成0时,cpu进入实模式;
mov eax, cr0
or eax, 1
mov cr0, eax; 进入保护模式











# **本科实验报告——实验九**

- **实验项目名称：编译支持的流水线处理器**   

- **学生姓名：段皞一**      
- **学号：3190105359**          

- **实验地点：紫金港东四509室**  
- **实验日期：2021 年 5 月 26 日**

## 一、操作方法与实验步骤

###  1. 搭建流水线CPU测试应用环境

![image-20210601134413210](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210601134413210.png)

**1.1 分解实验七数据通路为五个子部件**

实验中，根据指令微操作分解单周期数据通路。单周期数据通路分解为五个子模块：每个子模块核心操作是组成电路；模块间用锁存器同步传输数据，每条指令5个时钟完成。

下图是流水线数据通路的示意图：

![image-20210601134728463](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210601134728463.png)

**1.1.1 IF微操作**

IF/ID寄存器模块的代码如下所示：

```verilog
module REG_IF_ID(
    input clk,
    input rst,
    input EN,                      //流水寄存器使能
    input Data_stall,              //数据竞争等待，保留
    input flush,                   //控制竞争清除并等待，保留
    input [31:0] PCOUT,            //指令存贮器指针
    input [31:0] IR,               //指令存储器输出
    
    output reg [31:0] ID_IR,      //取值锁存
    output reg [31:0] ID_PCurrent //当前存在指令地址
    );
    
    //reg[31:0]ID_PCurrent, ID_IR
    always @(posedge clk) begin
        if (rst) begin
            ID_IR <= 32'h0000_0000;        //复位清零
            ID_PCurrent <= 32'h0000_0000;  //复位清零
        end 
        else if (EN) begin
            ID_IR <= IR;            //锁存指令传送ID流水级译码
            ID_PCurrent <= PCOUT;   //传送当前取指PC，Branch/Jump指令计算目标地址（非PC+4）
        end                  
        else begin
            ID_IR <= ID_IR;            //保持
            ID_PCurrent <= ID_PCurrent;   
        end
    end
endmodule
```

IF微操作在数据通路中的实现如下：

```verilog
    //IF stage
    reg [31:0] PCNEXT;
    wire [31:0] PC_4 = PCOUT + 4;
    wire [31:0] PC_Jump = MEM_Target;
    wire [31:0] PC_Branch = MEM_Target;
    wire MEM_blt;
    
    wire Btake = ((MEM_blt == 1) ? MEM_zero : ~MEM_zero) && MEM_Branch;
    assign PCSource = {MEM_Jump, Btake};
    wire PCWR = PCEN;
    wire [31:0] MEM_ALUO;
    
   always @* begin
    case (PCSource)
        2'b00: PCNEXT = PC_4;
        2'b01: PCNEXT = PC_Branch;
        2'b10: PCNEXT = PC_Jump;
        2'b11: PCNEXT = MEM_ALUO;
    endcase
   end
    
    REG32 PC
         (.CE(PCWR),
          .D(PCNEXT),
          .Q(PCOUT),
          .clk(clk),
          .rst(rst)
          );
    //IF/ID Latch          
    REG_IF_ID IFID(
        .clk(clk),
        .rst(rst),
        .EN(1'b1),
        .Data_stall(),
        .flush(),
        .PCOUT(PCOUT),
        .IR(inst_field),
        .ID_IR(ID_IR),
        .ID_PCurrent(ID_PCurrent)
    );
```

**1.1.2 ID/EX微操作**

ID/EX寄存器的代码如下所示：

```verilog
module REG_ID_EX(
    input clk,                    //ID/EX Latch
    input rst,
    input EN,
    input flush,
    input [31:0] ID_IR,
    input [31:0] ID_PCurrent,
    input [31:0] rs1_data,
    input [31:0] rs2_data,
    input [31:0] Imm32,
    input [4:0] rd_addr,
    input [1:0] ALUSrc_A,
    input [1:0] ALUSrc_B,
    input [2:0] ALUC,
    input [1:0] DatatoReg,
    input RegWrite,
    input Jump,
    input Branch,
    input WR,
    input MIO,
    input sign,
    input blt, 
    input jen,
    
    output reg [31:0] EX_PCurrent,
    output reg [31:0] EX_IR,
    output reg [31:0] EX_A,
    output reg [31:0] EX_B,
    output reg [31:0] EX_Imm32,
    output reg [4:0] EX_rd,
    output reg EX_ALUSrc_A,
    output reg EX_ALUSrc_B,
    output reg [2:0] EX_ALUC,
    output reg [1:0] EX_DatatoReg,
    output reg EX_RegWrite,
    output reg EX_Jump,
    output reg EX_Branch,
    output reg EX_WR,
    output reg EX_MIO,
    output reg EX_sign,
    output reg EX_blt,
    output reg EX_jen
    );
    
    always @(posedge clk) begin
        if (rst) begin
            EX_rd <= 0;
            EX_RegWrite <= 0;
            EX_Jump <= 0;
            EX_Branch <= 0;
            EX_WR <= 0;
            EX_MIO <= 0;
            EX_blt <= 1;
            EX_jen <= 0;
            EX_IR <= 32'h0000_0000;
            EX_PCurrent <= 32'h0000_0000;
        end
        else if (EN) begin
            EX_PCurrent <= ID_PCurrent;
            EX_IR <= ID_IR;
            EX_A <= rs1_data;
            EX_B <= rs2_data;
            EX_Imm32 <= Imm32;
            EX_rd <= rd_addr;
            EX_ALUSrc_A <= ALUSrc_A;
            EX_ALUSrc_B <= ALUSrc_B;
            EX_ALUC <= ALUC;
            EX_DatatoReg <= DatatoReg;
            EX_Jump <= Jump;
            EX_Branch <= Branch;
            EX_RegWrite <= RegWrite;
            EX_WR <= WR;
            EX_MIO <= MIO;
            EX_blt <= blt;
            EX_jen <= jen;
            EX_sign <= sign;
        end
    end
endmodule
```

ID/EX微操作在数据通路中的实现代码如下所示：

```verilog
    //ID stage
    wire [4:0] rs1_addr = ID_IR[19:15];
    wire [4:0] rs2_addr = ID_IR[24:20];
    wire [4:0] rd_addr = ID_IR[11:7];
    wire [4:0] WB_rd;
    wire WB_RegWrite;

      regs DU2(
          .clk(clk),
          .rst(rst),
          .Wt_data(Wt_data),
          .rdata_A(rs1_data),
          .rdata_B(rs2_data),
          .R_addr_A(rs1_addr),
          .R_addr_B(rs2_addr),
          .Wt_addr(WB_rd),
          .L_S(WB_RegWrite),
          .Debug_addr(Debug_addr[4:0]),
          .Debug_regs(Debug_regs)
      );

    ImmGen ImmGen_0
         (.s(ImmSel),
          .sign(1),
          .o(Imm32),
          .I(ID_IR));
    
    //ID/EX Latch
    wire [31:0] EX_A, EX_B, EX_Imm32;
    wire [4:0] EX_rd;
    wire [2:0] EX_ALUC;
    wire [1:0] EX_DatatoReg;
    wire EX_ALUSrc_A, EX_ALUSrc_B, EX_Jump, EX_Branch, EX_RegWrite, EX_WR, EX_MIO, EX_sign, EX_jen, EX_blt;
          
    REG_ID_EX IDEX(
        .clk(clk),
        .rst(rst),
        .EN(1'b1),
        .flush(1'b0),
        .ID_IR(ID_IR),
        .ID_PCurrent(ID_PCurrent),
        .rs1_data(rs1_data),
        .rs2_data(rs2_data),
        .Imm32(Imm32),
        .rd_addr(rd_addr),
        .ALUSrc_A(ALUSrc_A),
        .ALUSrc_B(ALUSrc_B),
        .ALUC(ALUC),
        .DatatoReg(DatatoReg),
        .RegWrite(RegWrite),
        .Jump(Jump),
        .Branch(Branch),
        .WR(WR),
        .MIO(MIO),
        .jen(jen),
        .blt(blt),
        .sign(sign),
        
        .EX_PCurrent(EX_PCurrent),
        .EX_IR(EX_IR),
        .EX_A(EX_A),
        .EX_B(EX_B),
        .EX_Imm32(EX_Imm32),
        .EX_rd(EX_rd),
        .EX_ALUSrc_A(EX_ALUSrc_A),
        .EX_ALUSrc_B(EX_ALUSrc_B),
        .EX_ALUC(EX_ALUC),
        .EX_DatatoReg(EX_DatatoReg),
        .EX_RegWrite(EX_RegWrite),
        .EX_Jump(EX_Jump),
        .EX_Branch(EX_Branch),
        .EX_WR(EX_WR),
        .EX_MIO(EX_MIO),
        .EX_jen(EX_jen),
        .EX_blt(EX_blt),
        .EX_sign(EX_sign)
    );        
```

**1.1.3 EX/MEM微操作**

EX/MEM寄存器的代码如下：

```verilog
module REG_EX_MEM(
    input clk,
    input rst,
    input EN,
    input flush,
    input [31:0] EX_IR,
    input [31:0] EX_PCurrent,
    input [31:0] EX_ALUO,
    input zero,
    input [31:0] EX_B,
    input [31:0] EX_Target, //EX级计算：控制流地址
    input [4:0] EX_rd,
    input [1:0] EX_DatatoReg,
    input EX_RegWrite,
    input EX_Jump,
    input EX_Branch,
    input EX_WR,
    input EX_MIO,
    input EX_blt,
    input EX_jen,
    
    output reg [31:0] MEM_PCurrent,
    output reg [31:0] MEM_IR,
    output reg [31:0] MEM_ALUO,
    output reg [31:0] MEM_Datao,
    output reg [31:0] MEM_Target, //Branch or Jump Target address: PC+Imm32
    output reg [4:0] MEM_rd,
    output reg [1:0] MEM_DatatoReg,
    output reg MEM_zero,
    output reg MEM_RegWrite,
    output reg MEM_Jump,
    output reg MEM_Branch,
    output reg MEM_WR,
    output reg MEM_MIO,
    output reg MEM_blt,
    output reg MEM_jen
    );
    
    always @(posedge clk) begin
        if (rst) begin
            MEM_IR <= 0;
            MEM_PCurrent <= 0;
            MEM_Target <= 0;
            MEM_rd <= 0;
            MEM_RegWrite <= 0;
            MEM_Jump <= 0;
            MEM_Branch <= 0;
            MEM_WR <= 0;
            MEM_MIO <= 0;
            MEM_blt <= 1;
            MEM_jen <= 0;
        end
        else if (EN) begin
            MEM_IR <= EX_IR;
            MEM_PCurrent <= EX_PCurrent;
            MEM_Target <= EX_Target;
            MEM_ALUO <= EX_ALUO;
            MEM_zero <= zero;
            MEM_Datao <= EX_B;
            MEM_DatatoReg <= EX_DatatoReg;
            MEM_Jump <= EX_Jump;
            MEM_Branch <= EX_Branch;
            MEM_RegWrite <= EX_RegWrite;
            MEM_WR <= EX_WR;
            MEM_MIO <= EX_MIO;
            MEM_blt <= EX_blt;
            MEM_jen <= EX_jen;
            MEM_rd <= EX_rd;
        end
    end
endmodule
```

EX/MEM微操作的实现代码如下：

```verilog
    //EXE stage        
    wire [31:0] EX_ALUO;
    assign ALUA = EX_A;
    assign ALUB = EX_ALUSrc_B ? EX_Imm32 : EX_B;
    wire [31:0] EX_Target = EX_PCurrent + EX_Imm32;
                
    ALU_5359 ALU
         (.A(ALUA), 
          .B(ALUB),
          .sign(EX_sign),
          .ALU_operation(EX_ALUC),
          .res(EX_ALUO),
          .zero(zero)
          );
                
    //EX/MEM Latch
    wire [31:0] MEM_Datao;
    wire [4:0] MEM_rd;
    wire [1:0] MEM_DatatoReg;
    wire MEM_RegWrite, MEM_WR, MEM_MIO, MEM_jen;

    REG_EX_MEM EXMEM(
        .clk(clk),
        .rst(rst),
        .EN(1'b1),
        .flush(),
        .EX_IR(EX_IR),
        .EX_PCurrent(EX_PCurrent),
        .EX_B(EX_B), .EX_ALUO(EX_ALUO), .EX_Target(EX_Target), .zero(zero), .EX_rd(EX_rd),
        .EX_DatatoReg(EX_DatatoReg), .EX_RegWrite(EX_RegWrite), .EX_Jump(EX_Jump),
        .EX_Branch(EX_Branch), .EX_WR(EX_WR), .EX_MIO(EX_MIO), .EX_jen(EX_jen), .EX_blt(EX_blt),
        
        .MEM_PCurrent(MEM_PCurrent), .MEM_IR(MEM_IR), .MEM_ALUO(MEM_ALUO), .MEM_Datao(MEM_Datao),
        .MEM_Target(MEM_Target), .MEM_rd(MEM_rd), .MEM_DatatoReg(MEM_DatatoReg), .MEM_RegWrite(MEM_RegWrite),
        .MEM_zero(MEM_zero), .MEM_Jump(MEM_Jump), .MEM_Branch(MEM_Branch), .MEM_WR(MEM_WR), .MEM_MIO(MEM_MIO), .MEM_jen(MEM_jen), .MEM_blt(MEM_blt) );
```

**1.1.4 MEM微操作**

MEM/WB寄存器的代码如下：

```verilog
module REG_MEM_WB(
    input clk,
    input rst,
    input EN,
    input [31:0] MEM_IR,
    input [31:0] MEM_PCurrent,
    input [31:0] MEM_ALUO,
    input [31:0] Datai,
    input [4:0] MEM_rd,
    input [1:0] MEM_DatatoReg,
    input MEM_RegWrite,
    
    output reg [31:0] WB_PCurrent,
    output reg [31:0] WB_IR,
    output reg [31:0] WB_ALUO,
    output reg [31:0] WB_MDR,  //锁存MIO送入CPU输入数据
    output reg [4:0] WB_rd,
    output reg [1:0] WB_DatatoReg,
    output reg WB_RegWrite
    );
    
    always @(posedge clk) begin
        if (rst) begin
            WB_rd <= 0;
            WB_RegWrite <= 0;
            WB_IR <= 0;
            WB_PCurrent <= 0;
        end
        else if (EN) begin
            WB_IR <= MEM_IR;
            WB_PCurrent <= MEM_PCurrent;
            WB_ALUO <= MEM_ALUO;
            WB_MDR <= Datai;
            WB_rd <= MEM_rd;
            WB_RegWrite <= MEM_RegWrite;
            WB_DatatoReg <= MEM_DatatoReg;
        end
    end
endmodule
```

MEM微操作在数据通路中的实现代码如下所示：

```verilog
    //MEM stage
    assign Data_out = MEM_Datao;
    assign ALU_out = MEM_ALUO;
    assign MWR = MEM_WR;
    wire [31:0] WB_ALUO, WB_MDR;
    wire [1:0] WB_DatatoReg;
    
    //MEM/WB Latch
    REG_MEM_WB MEMWB(
        .clk(clk), .rst(rst), .EN(1'b1), .MEM_IR(MEM_IR), .MEM_PCurrent(MEM_PCurrent),
        .MEM_ALUO(MEM_ALUO), .Datai(Data_in), .MEM_rd(MEM_rd),
        .MEM_DatatoReg(MEM_DatatoReg), .MEM_RegWrite(MEM_RegWrite),
        
        .WB_PCurrent(WB_PCurrent), .WB_IR(WB_IR), .WB_ALUO(WB_ALUO), .WB_MDR(WB_MDR),
        .WB_rd(WB_rd), .WB_DatatoReg(WB_DatatoReg), .WB_RegWrite(WB_RegWrite) 
    );
```

**1.1.5 WB微操作**

WB阶段的寄存代码如下所示：

```verilog
    // WB stage - - - - - - - - - - - - - - - - - - - - - - - - - -            
    always @* begin
        case (WB_DatatoReg)
            2'b00: Wt_data = WB_ALUO;
            2'b01: Wt_data = WB_MDR;
            2'b10: Wt_data = WB_PCurrent + 4;
            2'b11: Wt_data = {WB_IR[31:12], 12'b0000_0000_0000}; // lui 扩展
        endcase
    end    
```

**1.2 更改之前实验的寄存器堆模块**

为了避免读写的冲突，寄存器堆模块把数据的写入改成下降沿触发。相关代码如下所示：

```verilog
module regs(
    input clk, 
    input rst, 
    input [4:0] R_addr_A,
    input [4:0] R_addr_B,
    input [4:0] Wt_addr,
    input [31:0] Wt_data,    
    input L_S,
    output [31:0] rdata_A,
    output [31:0] rdata_B,
    input [4:0] Debug_addr,
    output [31:0] Debug_regs
    );
    
reg [31:0] register [1:31];
integer i;

assign rdata_A = (R_addr_A==0) ? 0 : register[R_addr_A];
assign rdata_B = (R_addr_B==0) ? 0 : register[R_addr_B];

always @ (negedge clk)
begin
    if (rst == 1) begin
        for (i=1; i<32; i=i+1) 
            register[i] <= 0;
    end
    else begin
        if ((Wt_addr != 0) && (L_S == 1))
            register[Wt_addr] <= Wt_data;
    end
end
    assign Debug_regs = (Debug_addr == 0) ? 0 : register[Debug_addr];
endmodule
```

**1.3 控制器模块的修改**

数据通路流水分解后，控制器需要具备以下几个功能：产生为微操作控制信号（ALU的运算控制）；数据传输通道控制（选择所需的路径）；时序控制（确定单周期时序所在的位置）。不过，本实验由于没有处理竞争的情况，仍然沿用单周期的控制，只需做一些微小的修改，方便之后进行扩展。

```verilog
`define CPU_ctrl_signals \
    {ImmSel, ALUSrc_B, DatatoReg, RegWrite, MemRead, MemWrite, Branch, Jump, ALUop, jen, rs1_used, rs2_used, CPU_MIO}   
    
    module RV32IPCU_C(
        input clk,
        input reset,
        input [4:0] OPcode,
        input [2:0] Fun3,
        input Fun7,
        input MIO_ready,
        input zero,
        output reg jen,
        output reg ALUSrc_A,
        output reg ALUSrc_B,
        output reg [1:0]ImmSel,
        output reg [1:0]DatatoReg,
        output PCEN,
        output reg Jump,
        output reg Branch,
        output reg RegWrite,
        output WR,
        output reg blt,
        output reg [2:0]ALUC,
        output reg rs1_used,
        output reg rs2_used,
        output reg sign,
        output reg CPU_MIO,
        output ALE
        );
        
        reg MemWrite;
        reg MemRead;
        reg [1:0] ALUop;
        wire [3:0] Fun;
        assign WR = MemWrite&&(~MemRead);
        assign ALE = ~clk;
        assign PCEN = 1; 
        
        always @* begin
            ALUSrc_A = 0;
            ALUSrc_B = 0;
            DatatoReg = 0;
            RegWrite = 0;
            Branch = 0;
            Jump = 0;
            CPU_MIO = 0;
            ALUop = 0;
            rs1_used = 0;
            rs2_used = 0;
            case (OPcode)
            5'b01100 : begin `CPU_ctrl_signals = {2'b00,1'b0,2'b00,1'b1,1'b0,1'b0,1'b0,1'b0,2'b10,1'b0,1'b1,1'b1,1'b0}; end // ALU R-type
            5'b00000 : begin `CPU_ctrl_signals = {2'b00,1'b1,2'b01,1'b1,1'b1,1'b0,1'b0,1'b0,2'b00,1'b0,1'b1,1'b0,1'b1}; end // load type 00
            5'b01000 : begin `CPU_ctrl_signals = {2'b01,1'b1,2'b00,1'b0,1'b0,1'b1,1'b0,1'b0,2'b00,1'b0,1'b1,1'b1,1'b1}; end // store 01
            5'b11000 : begin `CPU_ctrl_signals = {2'b10,1'b0,2'b10,1'b0,1'b0,1'b0,1'b1,1'b0,2'b01,1'b0,1'b1,1'b1,1'b0}; end // Beq 10
            5'b11011 : begin `CPU_ctrl_signals = {2'b11,1'b1,2'b10,1'b1,1'b0,1'b0,1'b0,1'b1,2'b00,1'b0,1'b0,1'b0,1'b0}; end // J 11
            5'b00100 : begin `CPU_ctrl_signals = {2'b00,1'b1,2'b00,1'b1,1'b1,1'b0,1'b0,1'b0,2'b11,1'b0,1'b1,1'b0,1'b0}; end // addi
            5'b01101 : begin `CPU_ctrl_signals = {2'b00,1'b1,2'b11,1'b1,1'b0,1'b0,1'b0,1'b0,2'b00,1'b0,1'b0,1'b0,1'b0}; end // lui
            5'b11001 : begin `CPU_ctrl_signals = {2'b00,1'b1,2'b10,1'b1,1'b0,1'b0,1'b0,1'b1,2'b00,1'b1,1'b1,1'b0,1'b0}; end // jalr
            default : begin `CPU_ctrl_signals = {2'b00,1'b0,2'b00,1'b0,1'b0,1'b0,1'b0,1'b0,2'b11,1'b0,1'b0,1'b0,1'b0};  end 
            endcase
        end
            
           assign Fun = {Fun3,Fun7};
           always @(*) begin
                blt = 1;
                case(ALUop)
                2'b00: {ALUC, sign} = 4'b0101;
                2'b01: case(Fun3)
                    3'b000: {ALUC, blt, sign} = 5'b1101_1; //beq
                    3'b001: {ALUC, blt, sign} = 5'b1100_1; //bne
                    3'b100: {ALUC, blt, sign} = 5'b1110_1; //blt
                endcase
                2'b10: case(Fun)
                        4'b0000:{ALUC, sign} = 4'b0101; //add
                        4'b0001:{ALUC, sign} = 4'b1101; //sub
                        4'b1110:{ALUC, sign} = 4'b0001; //and
                        4'b1100:{ALUC, sign} = 4'b0011; //or
                        4'b0100:{ALUC, sign} = 4'b1111; //slt
                        4'b0110:{ALUC, sign} = 4'b1110; //sltu
                        4'b1010:{ALUC, sign} = 4'b1011; //srl
                        4'b1000:{ALUC, sign} = 4'b0111; //xor
                       default: {ALUC, sign} = 4'bx; 
                       endcase
               2'b11: case(Fun3)
                       3'b000:{ALUC, sign} = 4'b0101;  //addi
                       3'b001:{ALUC, sign} = 4'b1011; //slli
                       3'b010:{ALUC, sign} = 4'b1111; //slti
                       3'b011:{ALUC, sign} = 4'b1110; //sltiu
                       3'b100:{ALUC, sign} = 4'b0111;  //xori
                       3'b101:{ALUC, sign} = 4'b1011;  //srli
                       3'b110:{ALUC, sign} = 4'b0011;  //ori
                       3'b111:{ALUC, sign} = 4'b0001; //andi
                      default: {ALUC, sign} = 4'bx;
                      endcase
              endcase
              end
    endmodule
```

**1.4 上层模块的注意事项**

实验中，MIO信号需要使用EX/MEM微操作阶段存储的MEM_MIO(在本项目代码中为M_MIO)，更改RV32PCPU模块的输出为M_MIO，用于顶层模块。

```verilog
module RV32PCPU(
               input clk,
               input reset,                     //rst
               input Ready,                     //MIO_ready
               input [31:0]Datai, 
               output [31:0]Datao, 
               output [31:0]Addr, 
               output [31:0]PC, 
               input [31:0]INST,                //inst_in
               input [7:0]TNI, 
               output ALE, 
               output M_MIO, 
               output MWR,
               input [6:0] Debug_addr,
               output [31:0] Debug_data
               );
```

在顶层模块中使用到M_MIO的相关部分：

```verilog
    wire [31:0] MEM_Addr = SWO[13] ? M_MIO ? {20'h0000, ram_addr, 2'b00} : 32'hFFFF_FFFF
                                    : PC;
    wire [31:0] MEM_Data = SWO[13] ? M_MIO ? ram_data_out : 32'hAA55_AA55
                                    : inst;
```

在CPUTEST模块中，输入信号由原来的MIO更改为M_MIO。

```verilog
    CPUTEST    U1_3( .PC_IF(PC),
                     .PC_ID(ID_PCurrent),
                     .PC_EXE(EX_PCurrent),
                     .PC_MEM(MEM_PCurrent),
                     .PC_WB(WB_PCurrent),
                     .PC_next_IF(MEM_Target),
                     .PCJump(MEM_Target),
                     .inst_IF(INST),
                     .inst_ID(ID_IR),
                     .inst_EXE(EX_IR),
                     .inst_MEM(MEM_IR),
                     .inst_WB(WB_IR),
                     .PCEN(PCEN),
                     .Branch(Branch),
                     .PCSource(PCSource),
                     .Imm32(Imm32),
                     .ImmSel(ImmSel),
                     .RS1DATA(RS1DATA),
                     .RS2DATA(RS2DATA),
                     .ALUC(ALUC),
                     .Datai(Datai),
                     .Datao(Datao),
                     .ALU_out(Addr),
                     .Addr(Addr),
                     .A(A),
                     .B(B),
                     .WDATA(WDATA),
                     .DatatoReg(DatatoReg),
                     .ALUSrc_A(ALUSrc_A),
                     .ALUSrc_B(ALUSrc_B),
                     .WR(MWR),
                     .MIO(M_MIO), // 输入信号由原来的MIO更改为M_MIO
                     .RegWrite(RegWrite),
                     .data_hazard(Data_stall),
                     .control_hazard(BJ_stall),
                     
                     .Debug_addr(Debug_addr[4:0]),
                     .Test_signal(Test_signal)    
                    );
```

### **2. 对数据通路进行仿真分析**

**2.1 设计汇编代码方便进行仿真验证**

书写一个简易的汇编代码用于进行仿真。

```assembly
lw x5, 12(x0)
nop
nop
nop
slt x6, x0, x5
nop
nop
add x7, x6, x6
or x12, x9, x30
sub x13, x0, x6
beq x0, x0, begin
add x0, x0, x0
begin:
jal x0, end
end:
add x1, x1, x2
```

在venus在线汇编平台上将书写的汇编代码翻译成机器码：

```assembly
0x00C02283
0x00000013
0x00000013
0x00000013
0x00502333
0x00000013
0x00000013
0x006303B3
0x01E4E633
0x406006B3
0x00000463
0x00000033
0x0040006F
0x002080B3
```

**2.2 书写仿真代码**

书写完整的数据通路整体仿真代码，验证各级之间的数据传输，其次是微操作功能。相关的代码如下所示：

```verilog
module sim;
reg clk;
reg rst;
reg [31:0] inst_field;
reg [31:0] Data_in;
reg rs1_used;
reg rs2_used;
reg ALUSrc_A;
reg ALUSrc_B;
reg [2:0] ALUC;
reg [1:0] ImmSel;
reg [1:0] DatatoReg;
reg PCEN;
reg Jump;
reg Branch;
reg RegWrite;
reg WR;
reg MIO;
reg sign;
reg jen;
reg blt;

wire [31:0] PCOUT;
wire [31:0] ID_IR;
wire [31:0] Data_out;
wire MWR;
wire M_MIO;
wire [31:0] ALU_out;
wire overflow;
wire zero;

wire [31:0]rs1_data;
wire [31:0]rs2_data;
wire [31:0]Imm32;
wire [31:0]Wt_data;
wire [31:0]ALUA;
wire [31:0]ALUB;
wire BJ_stall;
wire Data_stall;
wire [1:0] PCSource;
wire [31:0] ID_PCurrent;
wire [31:0] EX_IR;
wire [31:0] EX_PCurrent;
wire [31:0] MEM_IR;
wire [31:0] MEM_PCurrent;
wire [31:0] MEM_Target;
wire [31:0] WB_IR;
wire [31:0] WB_PCurrent;
wire [6:0] Debug_addr;
wire [31:0] Debug_regs;

RV32IPDP_C U1(
    .clk(clk),
    .rst(rst),
    .inst_field(inst_field),
    .Data_in(Data_in),
    .rs1_used(rs1_used),
    .rs2_used(rs2_used),
    .ALUSrc_A(ALUSrc_A),
    .ALUSrc_B(ALUSrc_B),
    .ALUC(ALUC),
    .ImmSel(ImmSel),
    .DatatoReg(DatatoReg),
    .PCEN(PCEN),
    .Jump(Jump),
    .Branch(Branch),
    .RegWrite(RegWrite),
    .WR(WR),
    .MIO(MIO),
    .sign(sign),
    .jen(jen),
    .blt(blt),
    
    .PCOUT(PCOUT),
    .ID_IR(ID_IR),
    .Data_out(Data_out),
    .MWR(MWR),
    .M_MIO(M_MIO),
    .ALU_out(ALU_out),
    .overflow(overflow),
    .zero(zero),
    
    .rs1_data(rs1_data),
    .rs2_data(rs2_data),
    .Imm32(Imm32),
    .Wt_data(Wt_data),
    .ALUA(ALUA),
    .ALUB(ALUB),
    .BJ_stall(BJ_stall),
    .Data_stall(Data_stall),
    .PCSource(PCSource),
    .ID_PCurrent(ID_PCurrent),
    .EX_IR(EX_IR),
    .EX_PCurrent(EX_PCurrent),
    .MEM_IR(MEM_IR),
    .MEM_PCurrent(MEM_PCurrent),
    .MEM_Target(MEM_Target),
    .WB_IR(WB_IR),
    .WB_PCurrent(WB_PCurrent),
    .Debug_addr(Debug_addr),
    .Debug_regs(Debug_regs) 
    );
    
parameter clk_period = 10;

initial begin
rst = 1; clk = 0; #10;
rst = 0; 
// lw x5, 12(x0)
inst_field = 32'h00C02283; Data_in = 32'h1234_5678; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b00; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 1; sign = 1; jen = 0; blt = 1; #20;
// nop
inst_field = 32'h00000013; Data_in = 32'h0000_2222; rs1_used = 1; rs2_used = 0; ALUSrc_A = 0; ALUSrc_B = 1; ALUC = 2'b11; ImmSel = 2'b00;
DatatoReg = 2'b00; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// nop
inst_field = 32'h00000013; Data_in = 32'h0000_2222; rs1_used = 1; rs2_used = 0; ALUSrc_A = 0; ALUSrc_B = 1; ALUC = 2'b11; ImmSel = 2'b00;
DatatoReg = 2'b00; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// nop
inst_field = 32'h00C00013; Data_in = 32'h0000_2222; rs1_used = 1; rs2_used = 0; ALUSrc_A = 0; ALUSrc_B = 1; ALUC = 2'b11; ImmSel = 2'b00;
DatatoReg = 2'b00; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// slt x6, x0, x5
inst_field = 32'h00502333; Data_in = 32'h11111111; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// nop
inst_field = 32'h00000013; Data_in = 32'h0000_2222; rs1_used = 1; rs2_used = 0; ALUSrc_A = 0; ALUSrc_B = 1; ALUC = 2'b11; ImmSel = 2'b00;
DatatoReg = 2'b00; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// nop
inst_field = 32'h00000013; Data_in = 32'h0000_2222; rs1_used = 1; rs2_used = 0; ALUSrc_A = 0; ALUSrc_B = 1; ALUC = 2'b11; ImmSel = 2'b00;
DatatoReg = 2'b00; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// add x7, x6, x6
inst_field = 32'h006303B3; Data_in = 32'h2222_2222; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// or x12, x9, x30
inst_field = 32'h01E4E633; Data_in = 32'h3333_3333; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// sub x13, x0, x6
inst_field = 32'h406006B3; Data_in = 32'h4444_4444; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// beq x0, x0, begin
inst_field = 32'h00000463; Data_in = 32'h5555_5555; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// add x0, x0, x0
inst_field = 32'h00000033; Data_in = 32'h6666_6666; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// jal x0, end
inst_field = 32'h0040006F; Data_in = 32'h0000_0004; rs1_used = 0; rs2_used = 0; ALUSrc_A = 0; ALUSrc_B = 1; ALUC = 2'b00; ImmSel = 2'b11;
DatatoReg = 2'b10; PCEN = 1; Jump = 1; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;
// add x1, x1, x2
inst_field = 32'h002080B3; Data_in = 32'h7777_7777; rs1_used = 1; rs2_used = 1; ALUSrc_A = 0; ALUSrc_B = 0; ALUC = 2'b00; ImmSel = 2'b00;
DatatoReg = 2'b01; PCEN = 1; Jump = 0; Branch = 0; RegWrite = 1; WR = 0; MIO = 0; sign = 1; jen = 0; blt = 1; #20;

end

always #(clk_period)  begin
   clk = ~clk;
end

endmodule
```

**2.3 对仿真结果进行分析**

仿真生成的示意图如下所示：

![image-20210602190545968](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602190545968.png)

- 第一条指令

![image-20210602190849689](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602190849689.png)

指令信息：

| 指令          | 机器码     |
| ------------- | ---------- |
| lw x5, 12(x0) | 0x00C02283 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00C02283 |
| Data_out | X          |
| ALU_out  | X          |
| zero     | X          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x0000000C |
| Wt_data  | X          |
| ALUA     | X          |
| ALUB     | X          |
| PCSource | X          |
| EX_IR    | X          |
| MEM_IR   | X          |
| WB_IR    | X          |

这是仿真执行的第一条指令，很多寄存器的值还不确定。

- 第二条指令

![image-20210602191628580](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602191628580.png)

指令信息：

| 指令 | 机器码     |
| ---- | ---------- |
| nop  | 0x00000013 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000013 |
| Data_out | X          |
| ALU_out  | X          |
| zero     | 0          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | X          |
| ALUA     | 0x00000000 |
| ALUB     | 0x0000000C |
| PCSource | 0          |
| EX_IR    | 0x00C02283 |
| MEM_IR   | X          |
| WB_IR    | X          |

nop是伪指令，本质上在汇编编译执行的时候，将转化成指令代码 addi x0, x0, 0。是本实验中为了解决数据竞争而采用的软件停顿方法。从这一步已经能够发现，EX_IR寄存器已经存储了上一个指令的机器码，可见ID/EX模块的设计是正确的。

- 第三条指令

![image-20210602192110365](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602192110365.png)

指令信息：

| 指令 | 机器码     |
| ---- | ---------- |
| nop  | 0x00000013 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000013 |
| Data_out | 0x00000000 |
| ALU_out  | 0x0000000C |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | X          |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x00000013 |
| MEM_IR   | 0x00C02283 |
| WB_IR    | X          |

EX_IR和MEM_IR分别存储了上一条、前一条指令，两个模块的设计均为正确的。

- 第四条指令

![image-20210602192432255](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602192432255.png)

指令信息：

| 指令 | 机器码     |
| ---- | ---------- |
| nop  | 0x00000013 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000013 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | 0x0000000C |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x00000013 |
| MEM_IR   | 0x00000013 |
| WB_IR    | 0x00C02283 |

在本条指令执行的过程中，第一条指令已经存储到了WB_IR中，可见相关模块的设计正确，下一条指令也可以执行了。

- 第五条指令

![image-20210602192740368](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602192740368.png)

指令信息：

| 指令           | 机器码     |
| -------------- | ---------- |
| slt x6, x0, x5 | 0x00502333 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00502333 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x0000000C |
| Imm32    | 0x00000000 |
| Wt_data  | 0x0000000C |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x00000013 |
| MEM_IR   | 0x00000013 |
| WB_IR    | 0x00C02283 |

- 第六条指令

![image-20210602194010436](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602194010436.png)

指令信息：

| 指令 | 机器码     |
| ---- | ---------- |
| nop  | 0x00000013 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000013 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 0          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | 0x00000000 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000005 |
| PCSource | 0          |
| EX_IR    | 0x00502333 |
| MEM_IR   | 0x00000013 |
| WB_IR    | 0x00000013 |

该指令是为了解决数据竞争而手动增加的停顿。

- 第七条指令

![image-20210602194222041](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602194222041.png)

指令信息：

| 指令 | 机器码     |
| ---- | ---------- |
| nop  | 0x00000013 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000013 |
| Data_out | 0x0000000C |
| ALU_out  | 0x00000005 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | 0x00002222 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x00000013 |
| MEM_IR   | 0x00502333 |
| WB_IR    | 0x00000013 |

- 第八条指令

![image-20210602194348094](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602194348094.png)

指令信息：

| 指令           | 机器码     |
| -------------- | ---------- |
| add x7, x6, x6 | 0x006303B3 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x006303B3 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000006 |
| Wt_data  | 0x00000005 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000005 |
| PCSource | 0          |
| EX_IR    | 0x00000013 |
| MEM_IR   | 0x00000013 |
| WB_IR    | 0x00502333 |

- 第九条指令

![image-20210602194533610](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602194533610.png)

指令信息：

| 指令            | 机器码     |
| --------------- | ---------- |
| or x12, x9, x30 | 0x01E4E633 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x01E4E633 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 0          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x0000001E |
| Wt_data  | 0x00000000 |
| ALUA     | 0x00000005 |
| ALUB     | 0x00000005 |
| PCSource | 0          |
| EX_IR    | 0x006303B3 |
| MEM_IR   | 0x00000013 |
| WB_IR    | 0x00000013 |

- 第十条指令

![image-20210602195333549](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602195333549.png)

指令信息：

| 指令            | 机器码     |
| --------------- | ---------- |
| sub x13, x0, x6 | 0x406006B3 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x01E4E633 |
| Data_out | 0x00000005 |
| ALU_out  | 0x00000005 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000005 |
| Imm32    | 0x00000406 |
| Wt_data  | 0x44444444 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x01E4E633 |
| MEM_IR   | 0x006303B3 |
| WB_IR    | 0x00000013 |

- 第十一条指令

![image-20210602195628719](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602195628719.png)

指令信息：

| 指令          | 机器码     |
| ------------- | ---------- |
| beq x0, x0, 8 | 0x00000463 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000463 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | 0x55555555 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000005 |
| PCSource | 0          |
| EX_IR    | 0x406006B3 |
| MEM_IR   | 0x01E4E633 |
| WB_IR    | 0x006303B3 |

- 第十二条指令

![image-20210602195844365](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602195844365.png)

指令信息：

| 指令           | 机器码     |
| -------------- | ---------- |
| add x0, x0, x0 | 0x00000033 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x00000033 |
| Data_out | 0x00000005 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000000 |
| Wt_data  | 0x66666666 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x00000463 |
| MEM_IR   | 0x406006B3 |
| WB_IR    | 0x01E4E633 |

- 第十三条指令

![image-20210602200039170](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602200039170.png)

指令信息：

| 指令      | 机器码     |
| --------- | ---------- |
| jal x0, 4 | 0x0040006F |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x0040006F |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000004 |
| Wt_data  | 0x00000004 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 0          |
| EX_IR    | 0x00000033 |
| MEM_IR   | 0x00000463 |
| WB_IR    | 0x406006B3 |

- 第十四条指令

![image-20210602200529175](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602200529175.png)

指令信息：

| 指令           | 机器码     |
| -------------- | ---------- |
| add x1, x1, x2 | 0x002080B3 |

相关控制信号和寄存器的值：

| 输出信号 | 真值       |
| -------- | ---------- |
| ID_IR    | 0x002080B3 |
| Data_out | 0x00000000 |
| ALU_out  | 0x00000000 |
| zero     | 1          |
| rs1_data | 0x00000000 |
| rs2_data | 0x00000000 |
| Imm32    | 0x00000002 |
| Wt_data  | 0x77777777 |
| ALUA     | 0x00000000 |
| ALUB     | 0x00000000 |
| PCSource | 2          |
| EX_IR    | 0x0040006F |
| MEM_IR   | 0x00000033 |
| WB_IR    | 0x00000463 |

经过检验，可以知道数据通路流水设计是正确的。



## 二、实验结果与分析

 **2.1 引脚约束文件**

本实验的引脚约束文件与之前实验的引脚约束文件一致：

```verilog
#系统时钟
set_property -dict {PACKAGE_PIN AC18 IOSTANDARD LVCMOS18} [get_ports clk_100mhz]

#Reset or CR
set_property -dict {PACKAGE_PIN W13  IOSTANDARD LVCMOS18} [get_ports RSTN]

#SWORD LED：LED同步串行接口
set_property -dict {PACKAGE_PIN N26  IOSTANDARD LVCMOS33} [get_ports LEDCK]   
set_property -dict {PACKAGE_PIN N24  IOSTANDARD LVCMOS33} [get_ports LEDCR]
set_property -dict {PACKAGE_PIN M26  IOSTANDARD LVCMOS33} [get_ports LEDDT]
set_property -dict {PACKAGE_PIN P18  IOSTANDARD LVCMOS33} [get_ports LEDEN]
 
#SWORD SEG：七段码同步串行接口
set_property -dict {PACKAGE_PIN M24  IOSTANDARD LVCMOS33} [get_ports SEGCK]
set_property -dict {PACKAGE_PIN M20  IOSTANDARD LVCMOS33} [get_ports SEGCR]
set_property -dict {PACKAGE_PIN L24  IOSTANDARD LVCMOS33} [get_ports SEGDT]
set_property -dict {PACKAGE_PIN R18  IOSTANDARD LVCMOS33} [get_ports SEGEN]

#Tri-LED：三色指示灯       #LEDR0  #LEDG0 #LEDR0
set_property -dict {PACKAGE_PIN U22  IOSTANDARD LVCMOS33} [get_ports readn]
set_property -dict {PACKAGE_PIN V22  IOSTANDARD LVCMOS33} [get_ports CR]   
set_property -dict {PACKAGE_PIN U21  IOSTANDARD LVCMOS33} [get_ports RDY]   
#set_property -dict {PACKAGE_PIN U24  IOSTANDARD LVCMOS33} [get_ports LEDR1]
#set_property -dict {PACKAGE_PIN U25  IOSTANDARD LVCMOS33} [get_ports LEDG1]
#set_property -dict {PACKAGE_PIN V23  IOSTANDARD LVCMOS33} [get_ports LEDB1]
                                     
#Arraykeys：阵列键盘-行
set_property -dict {PACKAGE_PIN V18 IOSTANDARD LVCMOS18} [get_ports {KCOL[0]}]
set_property -dict {PACKAGE_PIN V19 IOSTANDARD LVCMOS18} [get_ports {KCOL[1]}]
set_property -dict {PACKAGE_PIN V14 IOSTANDARD LVCMOS18} [get_ports {KCOL[2]}]
set_property -dict {PACKAGE_PIN W14 IOSTANDARD LVCMOS18} [get_ports {KCOL[3]}]
#Arraykeys：阵列键盘-列
set_property -dict {PACKAGE_PIN V17 IOSTANDARD LVCMOS18 PULLUP true} [get_ports {KROW[0]}] 
set_property -dict {PACKAGE_PIN W18 IOSTANDARD LVCMOS18 PULLUP true} [get_ports {KROW[1]}]
set_property -dict {PACKAGE_PIN W19 IOSTANDARD LVCMOS18 PULLUP true} [get_ports {KROW[2]}]
set_property -dict {PACKAGE_PIN W15 IOSTANDARD LVCMOS18 PULLUP true} [get_ports {KROW[3]}]
set_property -dict {PACKAGE_PIN W16 IOSTANDARD LVCMOS18 PULLUP true} [get_ports {KROW[4]}]
  
#SWitch：滑动开关                                     
set_property -dict {PACKAGE_PIN AA10 IOSTANDARD LVCMOS15} [get_ports {SW[0]}]
set_property -dict {PACKAGE_PIN AB10 IOSTANDARD LVCMOS15} [get_ports {SW[1]}]
set_property -dict {PACKAGE_PIN AA13 IOSTANDARD LVCMOS15} [get_ports {SW[2]}]
set_property -dict {PACKAGE_PIN AA12 IOSTANDARD LVCMOS15} [get_ports {SW[3]}]
set_property -dict {PACKAGE_PIN Y13  IOSTANDARD LVCMOS15} [get_ports {SW[4]}]
set_property -dict {PACKAGE_PIN Y12  IOSTANDARD LVCMOS15} [get_ports {SW[5]}]
set_property -dict {PACKAGE_PIN AD11 IOSTANDARD LVCMOS15} [get_ports {SW[6]}]
set_property -dict {PACKAGE_PIN AD10 IOSTANDARD LVCMOS15} [get_ports {SW[7]}]
set_property -dict {PACKAGE_PIN AE10 IOSTANDARD LVCMOS15} [get_ports {SW[8]}]
set_property -dict {PACKAGE_PIN AE12 IOSTANDARD LVCMOS15} [get_ports {SW[9]}]
set_property -dict {PACKAGE_PIN AF12 IOSTANDARD LVCMOS15} [get_ports {SW[10]}]
set_property -dict {PACKAGE_PIN AE8  IOSTANDARD LVCMOS15} [get_ports {SW[11]}]
set_property -dict {PACKAGE_PIN AF8  IOSTANDARD LVCMOS15} [get_ports {SW[12]}]
set_property -dict {PACKAGE_PIN AE13 IOSTANDARD LVCMOS15} [get_ports {SW[13]}]
set_property -dict {PACKAGE_PIN AF13 IOSTANDARD LVCMOS15} [get_ports {SW[14]}]
set_property -dict {PACKAGE_PIN AF10 IOSTANDARD LVCMOS15} [get_ports {SW[15]}]
             
#PS2 Key：PS2标准同步串行接口
#set_property -dict {PACKAGE_PIN M19  IOSTANDARD LVCMOS33 PULLUP true} [get_ports PS2D]
#set_property -dict {PACKAGE_PIN N18  IOSTANDARD LVCMOS33 PULLUP true} [get_ports PS2C]

#UART：异步串行接口
#set_property -dict {PACKAGE_PIN L25 IOSTANDARD LVCMOS33 PULLUP true} [get_ports RXD]
#set_property -dict {PACKAGE_PIN P24 IOSTANDARD LVCMOS33 DRIVE 16 SLEW FAST PULLUP true} [get_ports TXD]


#VGA
set_property -dict {PACKAGE_PIN N21  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Red[0]}]
set_property -dict {PACKAGE_PIN N22  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Red[1]}]
set_property -dict {PACKAGE_PIN R21  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Red[2]}]
set_property -dict {PACKAGE_PIN P21  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Red[3]}]
set_property -dict {PACKAGE_PIN R22  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Green[0]}]
set_property -dict {PACKAGE_PIN R23  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Green[1]}]
set_property -dict {PACKAGE_PIN T24  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Green[2]}]
set_property -dict {PACKAGE_PIN T25  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Green[3]}]
set_property -dict {PACKAGE_PIN T20  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Blue[0]}]
set_property -dict {PACKAGE_PIN R20  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Blue[1]}]
set_property -dict {PACKAGE_PIN T22  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Blue[2]}]
set_property -dict {PACKAGE_PIN T23  IOSTANDARD LVCMOS33 SLEW FAST} [get_ports {Blue[3]}]
set_property -dict {PACKAGE_PIN M22  IOSTANDARD LVCMOS33 SLEW FAST}  [get_ports HSYNC]
set_property -dict {PACKAGE_PIN M21  IOSTANDARD LVCMOS33 SLEW FAST}  [get_ports VSYNC]

#######################################################
#ArDUNIO-IO for LED
set_property -dict {PACKAGE_PIN AF24 IOSTANDARD LVCMOS33} [get_ports {LED[0]}]
set_property -dict {PACKAGE_PIN AE21 IOSTANDARD LVCMOS33} [get_ports {LED[1]}]
set_property -dict {PACKAGE_PIN Y22  IOSTANDARD LVCMOS33} [get_ports {LED[2]}]
set_property -dict {PACKAGE_PIN Y23  IOSTANDARD LVCMOS33} [get_ports {LED[3]}]
set_property -dict {PACKAGE_PIN AA23 IOSTANDARD LVCMOS33} [get_ports {LED[4]}]
set_property -dict {PACKAGE_PIN Y25  IOSTANDARD LVCMOS33} [get_ports {LED[5]}]
set_property -dict {PACKAGE_PIN AB26 IOSTANDARD LVCMOS33} [get_ports {LED[6]}]
set_property -dict {PACKAGE_PIN W23  IOSTANDARD LVCMOS33} [get_ports {LED[7]}]



#Arduino for Buzzer
set_property -dict {PACKAGE_PIN AF25 IOSTANDARD LVCMOS33} [get_ports Buzzer]

##ArDUNIO-IO for SEG
set_property -dict {PACKAGE_PIN AB22 IOSTANDARD LVCMOS33} [get_ports {SEGMENT[0]}]
set_property -dict {PACKAGE_PIN AD24 IOSTANDARD LVCMOS33} [get_ports {SEGMENT[1]}]
set_property -dict {PACKAGE_PIN AD23 IOSTANDARD LVCMOS33} [get_ports {SEGMENT[2]}]
set_property -dict {PACKAGE_PIN Y21  IOSTANDARD LVCMOS33} [get_ports {SEGMENT[3]}]
set_property -dict {PACKAGE_PIN W20  IOSTANDARD LVCMOS33} [get_ports {SEGMENT[4]}]
set_property -dict {PACKAGE_PIN AC24 IOSTANDARD LVCMOS33} [get_ports {SEGMENT[5]}]
set_property -dict {PACKAGE_PIN AC23 IOSTANDARD LVCMOS33} [get_ports {SEGMENT[6]}]
set_property -dict {PACKAGE_PIN AA22 IOSTANDARD LVCMOS33} [get_ports {SEGMENT[7]}]

set_property -dict {PACKAGE_PIN AD21 IOSTANDARD LVCMOS33} [get_ports {AN[0]}]
set_property -dict {PACKAGE_PIN AC21 IOSTANDARD LVCMOS33} [get_ports {AN[1]}]
set_property -dict {PACKAGE_PIN AB21 IOSTANDARD LVCMOS33} [get_ports {AN[2]}]
set_property -dict {PACKAGE_PIN AC22 IOSTANDARD LVCMOS33} [get_ports {AN[3]}]

###################################

#SD
#set_property -dict {PACKAGE_PIN AF23 IOSTANDARD LVCMOS33 SLEW FAST} [get_ports sdClk]
#set_property -dict {PACKAGE_PIN AD25 IOSTANDARD LVCMOS33 SLEW FAST PULLUP true} [get_ports sdCmd]
#set_property -dict {PACKAGE_PIN AE25 IOSTANDARD LVCMOS33 SLEW FAST PULLUP true} [get_ports {sdDat[0]}]
#set_property -dict {PACKAGE_PIN AE22 IOSTANDARD LVCMOS33 SLEW FAST PULLUP true} [get_ports {sdDat[1]}]
#set_property -dict {PACKAGE_PIN AF22 IOSTANDARD LVCMOS33 SLEW FAST PULLUP true} [get_ports {sdDat[2]}]
#set_property -dict {PACKAGE_PIN Y20  IOSTANDARD LVCMOS33 SLEW FAST PULLUP true} [get_ports {sdDat[3]}]
#set_property -dict {PACKAGE_PIN AE26 IOSTANDARD LVCMOS33} [get_ports sdCd]
#set_property -dict {PACKAGE_PIN AE23 IOSTANDARD LVCMOS33} [get_ports sdRst]

#Old Arduino
#set_property -dict {PACKAGE_PIN AF24 IOSTANDARD LVCMOS33} [get_ports {LED[7]}]
#set_property -dict {PACKAGE_PIN AE21 IOSTANDARD LVCMOS33} [get_ports {LED[6]}]
#set_property -dict {PACKAGE_PIN Y22  IOSTANDARD LVCMOS33} [get_ports {LED[5]}]
#set_property -dict {PACKAGE_PIN Y23  IOSTANDARD LVCMOS33} [get_ports {LED[4]}]
#set_property -dict {PACKAGE_PIN AA23 IOSTANDARD LVCMOS33} [get_ports {LED[3]}]
#set_property -dict {PACKAGE_PIN Y25  IOSTANDARD LVCMOS33} [get_ports {LED[2]}]
#set_property -dict {PACKAGE_PIN AB26 IOSTANDARD LVCMOS33} [get_ports {LED[1]}]
#set_property -dict {PACKAGE_PIN W23  IOSTANDARD LVCMOS33} [get_ports {LED[0]}]

#set_property -dict {PACKAGE_PIN AA22 IOSTANDARD LVCMOS33} [get_ports {segment[7]}]
#set_property -dict {PACKAGE_PIN AC23 IOSTANDARD LVCMOS33} [get_ports {segment[6]}]
#set_property -dict {PACKAGE_PIN AC24 IOSTANDARD LVCMOS33} [get_ports {segment[5]}]
#set_property -dict {PACKAGE_PIN W20  IOSTANDARD LVCMOS33} [get_ports {segment[4]}]
#set_property -dict {PACKAGE_PIN Y21  IOSTANDARD LVCMOS33} [get_ports {segment[3]}]
#set_property -dict {PACKAGE_PIN AD23 IOSTANDARD LVCMOS33} [get_ports {segment[2]}]
#set_property -dict {PACKAGE_PIN AD24 IOSTANDARD LVCMOS33} [get_ports {segment[1]}]
#set_property -dict {PACKAGE_PIN AB22 IOSTANDARD LVCMOS33} [get_ports {segment[0]}]

#set_property -dict {PACKAGE_PIN F10 IOSTANDARD LVCMOS33} [get_ports {anode[3]}]
#set_property -dict {PACKAGE_PIN G11 IOSTANDARD LVCMOS33} [get_ports {anode[2]}]
#set_property -dict {PACKAGE_PIN AB21 IOSTANDARD LVCMOS33} [get_ports {anode[1]}]
#set_property -dict {PACKAGE_PIN AC22 IOSTANDARD LVCMOS33} [get_ports {anode[0]}]
#set_property -dict {PACKAGE_PIN AF24 IOSTANDARD LVCMOS33} [get_ports buzzer]
```

**2.2 手工优化消除 $RISCV-DEMO9$ 测试程序的竞争**

之前实验中用到的测试程序汇编代码如下所示：

```assembly
jal x0, 32
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
start:
lw x5, 12(x0)
slt x6, x0, x5
add x7, x6, x6
add x28, x7, x6
add x14, x7, x7
add x5, x28, x28
add x5, x5, x5
add x29, x5, x28
add x30, x29, x29
add x30, x30, x30
add x8, x30, x28
add x30, x30, x30
add x30, x30, x30
add x31, x30, x29
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x30, x30, x30
add x9, x30, x30
or x12, x9, x30
add x18, x9, x9
add x5, x18, x18
add x5, x5, x5
loop:
sub x13, x0, x6
sw x12, 4(x9)
lw x11, 0(x9)
add x11, x11, x11
add x11, x11, x11
sw x11, 0(x9)
add x21, x21, x6
sw x21 0(x18)
lw x22 20(x0)
loop2:
lw x11, 0(x9)
add x11, x11, x11
add x11, x11, x11
sw x11, 0(x9)
lw x11 0(x9)
and x24, x11, x5
add x22, x22, x6
beq x22, x0, C_init
l_next:
lw x11, 0(x9)
add x23, x14, x14
add x25, x23, x23
add x23, x23, x25
and x24, x11, x23
beq x24, x0, L00
beq x24, x23, L11
add x23, x14, x14
beq x24, x23, L01
sw x21, 0(x18)
jal x0, loop2
L00:
beq x15, x13, L4
jal x0, L3
L4:
add x15, x13, x13
L3:
sw x15, 0(x18)
jal x0, loop2
L11:
lw x21, 96(x19)
sw x21, 0(x18)
jal x0, loop2
L01:
lw x21, 32(x19)
sw x21, 0(x18)
jal x0, loop2
C_init:
lw x22, 20(x0)
add x15, x15, x15
or x15, x15, x6
add x19, x19,, x14
and x19, x19, x14
and x19, x19, x8
add x21, x21, x6
beq x21, x13, L6
jal x0, L7
L6:
add x21, x0, x14
add x21, x21, x6
L7:
lw x11, 0(x9)
add x24, x11, x11
add x24, x24, x24
sw x24, 0(x9)
sw x12, 4(x9)
jal x0, l_next
```

可以发现，由于本实验仅仅建立了流水线结构，没有处理竞争，对汇编代码中的数据冲突、控制冲突问题是无法避免的。因此，实验中要通过手动在汇编代码中增加气泡nop指令的方法规避冲突。更改后的代码如下所示：

```assembly
jal x0, start
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
add x0, x0, x0
start:
lw x5, 12(x0)
nop
nop
slt x6, x0, x5
nop
nop
add x7, x6, x6
nop
nop
add x28, x7, x6
add x14, x7, x7
nop
add x5, x28, x28
nop
nop
add x5, x5, x5
nop
nop
add x29, x5, x28
nop
nop
add x30, x29, x29
nop
nop
add x30, x30, x30
nop
nop
add x8, x30, x28
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x31, x30, x29
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x30, x30, x30
nop
nop
add x9, x30, x30
nop
nop
or x12, x9, x30
add x18, x9, x9
nop
nop
add x5, x18, x18
nop
nop
add x5, x5, x5
loop:
sub x13, x0, x6
sw x12, 4(x9)
lw x11, 0(x9)
nop
nop
add x11, x11, x11
nop
nop
add x11, x11, x11
nop
nop
sw x11, 0(x9)
add x21, x21, x6
nop
nop
sw x21 0(x18)
lw x22 20(x0)
loop2:
lw x11, 0(x9)
nop
nop
add x11, x11, x11
nop
nop
add x11, x11, x11
nop
nop
sw x11, 0(x9)
lw x11 0(x9)
nop
nop
and x24, x11, x5
add x22, x22, x6
nop
nop
beq x22, x0, C_init
nop
nop
nop
l_next:
lw x11, 0(x9)
add x23, x14, x14
nop
nop
add x25, x23, x23
nop
nop
add x23, x23, x25
nop
nop
and x24, x11, x23
nop
nop
beq x24, x0, L00
nop
nop
nop
beq x24, x23, L11
nop
nop
nop
add x23, x14, x14
nop
nop
beq x24, x23, L01
nop
nop
nop
sw x21, 0(x18)
jal x0, loop2
nop
nop
nop
L00:
beq x15, x13, L4
nop
nop
nop
jal x0, L3
nop
nop
nop
L4:
add x15, x13, x13
nop
nop
L3:
sw x15, 0(x18)
jal x0, loop2
nop
nop
L11:
lw x21, 96(x19)
nop
nop
sw x21, 0(x18)
jal x0, loop2
nop
nop
nop
L01:
lw x21, 32(x19)
nop
nop
sw x21, 0(x18)
jal x0, loop2
nop
nop
nop
C_init:
lw x22, 20(x0)
add x15, x15, x15
nop
nop
or x15, x15, x6
add x19, x19,, x14
nop
nop
and x19, x19, x14
and x19, x19, x8
add x21, x21, x6
nop
nop
beq x21, x13, L6
jal x0, L7
nop
nop
nop
L6:
add x21, x0, x14
nop
nop
add x21, x21, x6
L7:
lw x11, 0(x9)
nop
nop
add x24, x11, x11
nop
nop
add x24, x24, x24
nop
nop
sw x24, 0(x9)
sw x12, 4(x9)
jal x0, l_next
nop
nop
nop
```

将代码在线上平台上生成机器码，进而生成.coe文件。

```assembly
memory_initialization_radix=16;
memory_initialization_vector=
0200006F,00000033,00000033,00000033,00000033,00000033,00000033,00000033,
00C02283,00000013,00000013,00502333,00000013,00000013,006303B3,00000013,00000013,
00638E33,00738733,00000013,01CE02B3,00000013,00000013,005282B3,00000013,00000013,
01C28EB3,00000013,00000013,01DE8F33,00000013,00000013,01EF0F33,00000013,00000013,
01CF0433,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01DF0FB3,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,
01EF0F33,00000013,00000013,01EF0F33,00000013,00000013,01EF04B3,00000013,00000013,
01E4E633,00948933,00000013,00000013,012902B3,00000013,00000013,005282B3,
406006B3,00C4A223,0004A583,00000013,00000013,00B585B3,00000013,00000013,
00B585B3,00000013,00000013,00B4A023,006A8AB3,00000013,00000013,01592023,
01402B03,0004A583,00000013,00000013,00B585B3,00000013,00000013,
00B585B3,00000013,00000013,00B4A023,0004A583,00000013,00000013,0055FC33,
006B0B33,00000013,00000013,100B0863,00000013,00000013,00000013,0004A583,
00E70BB3,00000013,00000013,017B8CB3,00000013,00000013,019B8BB3,00000013,00000013,
0175FC33,00000013,00000013,040C0863,00000013,00000013,00000013,
077C0E63,00000013,00000013,00000013,00E70BB3,00000013,00000013,
097C0063,00000013,00000013,00000013,01592023,F39FF06F,00000013,00000013,00000013,
02D78063,00000013,00000013,00000013,01C0006F,00000013,00000013,00000013,
00D687B3,00000013,00000013,00F92023,EF9FF06F,00000013,00000013,
0609AA83,00000013,00000013,01592023,EDDFF06F,00000013,00000013,00000013,
0209AA83,00000013,00000013,01592023,EBDFF06F,00000013,00000013,00000013,
01402B03,00F787B3,00000013,00000013,0067E7B3,00E989B3,00000013,00000013,
0089F9B3,006A8AB3,00000013,00000013,00DA8A63,0200006F,00000013,00000013,00000013,
00E00AB3,00000013,00000013,006A8AB3,0004A583,00000013,00000013,
00B58C33,00000013,00000013,018C0C33,00000013,00000013,0184A023,00C4A223,
E81FF06F,00000013,00000013,00000013;
```

**2.3 用优化后的测试程序调试此流水线的CPU构架**

- 测试lw x5, x0, 00Ch指令

![image-20210602224231018](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602224231018.png)

指令执行到最后一级后，计算结果写回寄存器堆，可以发现x5的值从之前的0变成了3F。lw指令执行正确。

![image-20210602224616783](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602224616783.png)

- 测试slt x6, x0, x5指令

![image-20210602224758010](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602224758010.png)

指令执行完毕，可以发现x6的值从原来的0变为1，与预期结果相符，可以得出结论：slt指令执行正确。

![image-20210602224927628](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602224927628.png)

- 验证指令add x7, x6, x6

![image-20210602225041936](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602225041936.png)

指令执行完毕后，x7 = x6+x6 = 2，观察VGA上的显示情况，与预期结果相符。可以得出结论：add指令执行正确。

![image-20210602225230786](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602225230786.png)

- 验证指令 or x0C, x09, x1E 的正确性

指令执行前，x0C = 0, x09 = 0, x1E = 32'h78000000. 预期结果为x0C = 32'h78000000.

![image-20210602225529237](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602225529237.png)

指令执行完毕后，可以观察到，x0C的值确实为32'h78000000，or指令执行正确。

![image-20210602225750575](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602225750575.png)

- 验证指令 sub x0D, x0, x6

指令执行前，x6 = 1，所以预期x0D = 32'hFFFFFFFF.

![image-20210602225902518](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602225902518.png)

执行指令以后，通过观察得出x0D的值确实为32'hFFFFFFFF，可知sub指令执行正确。

![image-20210602230100609](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602230100609.png)

- 验证指令 beq x18, x0, 0050 指令的正确性

执行指令以前，x18的值为0，所以按预期情况，应该执行跳转。

![image-20210602230524428](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602230524428.png)

执行指令以后，通过观察可知，PC确实进行了正确的跳转（02B8+0050=0308），所以beq指令执行是正确的。

![image-20210602230735949](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602230735949.png)

- 验证指令 jal x0, 001Ch

指令执行以前，PC = 0318. 按照预期指令执行以后PC=0318+001C = 0334.

![image-20210602230953644](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602230953644.png)

指令执行以后，可以观察到PC确实为0334h，可以得出结论：jal指令执行正确。

![image-20210602231215301](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20210602231215301.png)



## 三、讨论、心得

- 讨论和心得

本实验是流水线实验的第一个部分，在之前实验七的基础上，将单周期改造成流水线实现模式。通过本次实验，我对CPU结构有了更加深刻的认识。而且为了能够更好地完成实验，我是在学习和理解CPU性能优化方法——流水线的基础之上，进行实验的。

实验其实本身并不困难，需要构建五个寄存器模块组，传送5个微操作所需的参数。不过本实验的一大困难是MIO信号的选择问题。由于我使用了老的PPT作为实验的参考，上面是使用当前指令的MIO信号作为上层CPUTEST和顶层模块MEM_Addr的选择信号。一开始我没有仔细思考，就按照这一思路处理MIO，但是发现我的工程编译生成.bit文件上板验证时不能正确运行跑马灯，产生了典型的“AA5555AA”的问题。后来经过仔细地思考，MIO信号在流水线架构中应该使用之前的MIO即MEM_MIO，所以我把MIO做了和WR与MWR类似的处理，一直通过微操作的寄存器组模块传出MEM_MIO，作为CPUTEST和顶层MEM_Addr的相关信号，终于跑出了跑马灯，指令运行结果也正常了。

实验实现的过程中，曾经还犯了一个低级的错误，就是在

EX/MEM寄存器阶段传送时，漏传了DatatoReg，导致了DatatoReg一直是缺省值2'b00, 在选择PC阶段一致选择PC+4，导致了PC爆炸的问题，经过排查，总算是循环正常了。相关代码如下：

```verilog
REG_EX_MEM EXMEM(
        .clk(clk),
        .rst(rst),
        .EN(1'b1),
        .flush(Data_stall),
        .EX_IR(EX_IR),
        .EX_PCurrent(EX_PCurrent),
        .EX_B(EX_B), .EX_ALUO(EX_ALUO), .EX_Target(EX_Target), .zero(zero), .EX_rd(EX_rd),
        .EX_DatatoReg(EX_DatatoReg), .EX_RegWrite(EX_RegWrite), .EX_Jump(EX_Jump),
        .EX_Branch(EX_Branch), .EX_WR(EX_WR), .EX_MIO(EX_MIO), .EX_jen(EX_jen), .EX_blt(EX_blt),
        
        .MEM_PCurrent(MEM_PCurrent), .MEM_IR(MEM_IR), .MEM_ALUO(MEM_ALUO), .MEM_Datao(MEM_Datao),
        .MEM_Target(MEM_Target), .MEM_rd(MEM_rd), .MEM_DatatoReg(MEM_DatatoReg), 		       .MEM_RegWrite(MEM_RegWrite),
        .MEM_zero(MEM_zero), .MEM_Jump(MEM_Jump), .MEM_Branch(MEM_Branch), .MEM_WR(MEM_WR), .MEM_MIO(MEM_MIO), .MEM_jen(MEM_jen), .MEM_blt(MEM_blt) );

```

总之，在最终上板子验证，发现自己成功后，还是十分有成就感的。由于使用了老的PPT，我不得不自己分析 MIO 信号，反而加深了我对于该部分的理解和认识。



- 思考题

1. 本讲义详细分析了$9^+$条指令的通路流水分解，扩展下列指令，分解数据通路有什么不同：

| 指令类型 | 指令                                                      |
| -------- | --------------------------------------------------------- |
| R-Type   | sra, sll, sltu                                            |
| I-Type   | addi, andi, ori, xori, lui, slti, slti, srai, slli, sltiu |
| B-Type   | bne, blt                                                  |
| UJ-type  | jal                                                       |
| U-Type   | lui                                                       |

lui：DatatoReg选择器原先冗余的第四位使用起来，用来选择立即数左移12位的值。

bne, blt两个信号本质上要将zero取反，所以要设立blt信号，一直从blt->EX_blt->MEM_blt，最后方便进行Btake的赋值操作，进而选择正确的PC值。



2. 流水结构增加stall消除数据冒险竞争和flush消除控制冒险竞争，你认为应该先解决哪一个更好？

数据冒险在流水线中更加常见，所以我认为应该在流水结构中增加stall，首先解决数据冒险竞争，这样能够更大程度上提升流水结构的性能。



3. stall(flush)和forward相干性检测位置相同吗？

两者不一样。stall有Data_stall, BJ_stall, J_stall, 检测位置有ID, EXE, MEM阶段，而forward相干性检测在EXE阶段进行检测。